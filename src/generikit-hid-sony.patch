--- src/hid-sony.c	2024-10-07 19:24:20.074464057 -0300
+++ src/generikit-hid-sony.c	2024-10-07 19:20:36.494465858 -0300
@@ -40,9 +40,14 @@
 #include <linux/crc32.h>
 #include <linux/usb.h>
 #include <linux/timer.h>
-#include <linux/unaligned.h>
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  #include <linux/unaligned.h>
+#else
+  #include <asm/unaligned.h>
+#endif
 
-#include "hid-ids.h"
+#include "ids.h"
 
 #define VAIO_RDESC_CONSTANT       BIT(0)
 #define SIXAXIS_CONTROLLER_USB    BIT(1)
@@ -61,6 +66,7 @@
 #define GH_GUITAR_CONTROLLER      BIT(14)
 #define GHL_GUITAR_PS3WIIU        BIT(15)
 #define GHL_GUITAR_PS4            BIT(16)
+#define GENERIC_GAMEPAD           BIT(20)
 
 #define SIXAXIS_CONTROLLER (SIXAXIS_CONTROLLER_USB | SIXAXIS_CONTROLLER_BT)
 #define MOTION_CONTROLLER (MOTION_CONTROLLER_USB | MOTION_CONTROLLER_BT)
@@ -99,7 +105,12 @@
 };
 
 /* PS/3 Motion controller */
-static const u8 motion_rdesc[] = {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  static const
+#else
+  static
+#endif
+u8 motion_rdesc[] = {
 	0x05, 0x01,         /*  Usage Page (Desktop),               */
 	0x09, 0x04,         /*  Usage (Joystick),                   */
 	0xA1, 0x01,         /*  Collection (Application),           */
@@ -195,7 +206,12 @@
 	0xC0                /*  End Collection                      */
 };
 
-static const u8 ps3remote_rdesc[] = {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  static const
+#else
+  static
+#endif
+u8 ps3remote_rdesc[] = {
 	0x05, 0x01,          /* GUsagePage Generic Desktop */
 	0x09, 0x05,          /* LUsage 0x05 [Game Pad] */
 	0xA1, 0x01,          /* MCollection Application (mouse, keyboard) */
@@ -599,14 +615,24 @@
 	return 0;
 }
 
-static const u8 *motion_fixup(struct hid_device *hdev, u8 *rdesc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  static const
+#else
+  static
+#endif
+u8 *motion_fixup(struct hid_device *hdev, u8 *rdesc,
 			      unsigned int *rsize)
 {
 	*rsize = sizeof(motion_rdesc);
 	return motion_rdesc;
 }
 
-static const u8 *ps3remote_fixup(struct hid_device *hdev, u8 *rdesc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  static const
+#else
+  static
+#endif
+u8 *ps3remote_fixup(struct hid_device *hdev, u8 *rdesc,
 				 unsigned int *rsize)
 {
 	*rsize = sizeof(ps3remote_rdesc);
@@ -743,7 +769,12 @@
 	return -1;
 }
 
-static const u8 *sony_report_fixup(struct hid_device *hdev, u8 *rdesc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0))
+  static const
+#else
+  static
+#endif
+u8 *sony_report_fixup(struct hid_device *hdev, u8 *rdesc,
 		unsigned int *rsize)
 {
 	struct sony_sc *sc = hid_get_drvdata(hdev);
@@ -1142,6 +1173,13 @@
 	if (!buf)
 		return -ENOMEM;
 
+	/*
+	 * Generally a generic gamepad controller reports goes
+	 * beyond the desired limit. Skipping will make it work.
+	 */
+	if (sc->quirks & GENERIC_GAMEPAD)
+	{ goto out; }
+
 	ret = hid_hw_raw_request(hdev, 0xf2, buf, SIXAXIS_REPORT_0xF2_SIZE,
 				 HID_FEATURE_REPORT, HID_REQ_GET_REPORT);
 	if (ret < 0) {
@@ -1807,6 +1845,10 @@
 				SIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,
 				HID_REQ_GET_REPORT);
 
+		/* Dirty assignment to skip generic device report. */
+		if (sc->quirks & GENERIC_GAMEPAD)
+		{ ret = 17; }
+
 		if (ret != SIXAXIS_REPORT_0xF2_SIZE) {
 			hid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");
 			ret = ret < 0 ? ret : -EINVAL;
@@ -2054,18 +2096,34 @@
 
 static int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
-	int ret;
+	int ret = 0;
 	unsigned long quirks = id->driver_data;
 	struct sony_sc *sc;
 	struct usb_device *usbdev;
 	unsigned int connect_mask = HID_CONNECT_DEFAULT;
 
-	if (!strcmp(hdev->name, "FutureMax Dance Mat"))
-		quirks |= FUTUREMAX_DANCE_MAT;
+	/*
+	 * Read first 4 characters of 'hdev->name' to 'hdev_name_buffer',
+	 * ensuring that the characters are in UPPERCASE.
+	 */
+	unsigned char i = 0;
+	char hdev_name_buffer[5] = {0};
+	for (i=0; (i<4 && hdev->name[i]!='\0'); i++)
+	{ hdev_name_buffer[i] = hdev->name[i]-32; }
 
-	if (!strcmp(hdev->name, "SHANWAN PS3 GamePad") ||
-	    !strcmp(hdev->name, "ShanWan PS(R) Ga`epad"))
-		quirks |= SHANWAN_GAMEPAD;
+	/*
+	 * Filter out SONY controllers from being detected as some kind of generic device
+	 * avoiding assigning wrong values.
+	 */
+	if (strncmp(hdev_name_buffer, "SONY", 4))
+	{
+		if (!strcmp(hdev->name, "FutureMax Dance Mat"))
+		{ quirks |= FUTUREMAX_DANCE_MAT; }
+		else if (!strcmp(hdev->name, "SHANWAN PS3 GamePad") || !strcmp(hdev->name, "ShanWan PS(R) Ga`epad"))
+		{ quirks |= SHANWAN_GAMEPAD; }
+		else
+		{ quirks |= GENERIC_GAMEPAD; }
+  }
 
 	sc = devm_kzalloc(&hdev->dev, sizeof(*sc), GFP_KERNEL);
 	if (sc == NULL) {
@@ -2270,6 +2328,9 @@
 	/* Guitar Hero Live PS4 guitar dongles */
 	{ HID_USB_DEVICE(USB_VENDOR_ID_REDOCTANE, USB_DEVICE_ID_REDOCTANE_PS4_GHLIVE_DONGLE),
 		.driver_data = GHL_GUITAR_PS4 | GH_GUITAR_CONTROLLER },
+	/* Generic Device Joystick for PS3 */
+	{ HID_USB_DEVICE(USB_VENDOR_ID_GENERIC, USB_DEVICE_ID_GENERIC_GAMEPAD),
+		.driver_data = SIXAXIS_CONTROLLER_USB | GENERIC_GAMEPAD },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, sony_devices);
